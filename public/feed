<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Christopher Swenson</title>
  <id>http://www.caswenson.com/</id>
  <updated>2013-04-07T22:21:09-00:00</updated>
  <author>
    <name>Christopher Swenson</name>
  </author>
<entry><title>When to Start Testing and Why</title><link href="2013_04_07_when_to_start_testing_and_why" rel="alternate" /><id>2013_04_07_when_to_start_testing_and_why</id><published>2013-04-07T22:21:09-00:00</published><updated>2013-04-07T22:21:09-00:00</updated><author><name>Christopher Swenson</name></author><summary type="html">
&lt;p&gt;I didn't begin to really appreciate the value of proper testing in code until well into my curre</summary><content type="html">
&lt;p&gt;I didn't begin to really appreciate the value of proper testing in code until well into my current software engineering career. Testing wasn't something that came up during my formal education in computer science, since it isn't really relevant to the academic pursuit (except for perhaps a course in software engineering, most code you write academically is more about learning or exercising something than creating production code). Now, though, I love testing, and love how it helps ensure stability in my code.&lt;/p&gt;

&lt;p&gt;Two questions that come up when I talk to other people, especially relatively new programmers, are when should you learn how to test in a language or environment, and when in your project do you start testing on a given project?&lt;/p&gt;

&lt;p&gt;To answer the first question, the best time to learn to test (in my opinion) is after have started to get a good handle on the language and environment you're in, especially if this is the first language you've ever learned. The simple reason for this is that testing is often almost like an entirely new sub-language you have to learn, and it can be a little confusing to dive right into it.&lt;/p&gt;

&lt;p&gt;However, you really don't want to put it off for too long, especially if you've never written test code before. Writing good, idiomatic, testable code is an important skill, and living too long in a vacuum of untested code might make it harder to learn to write testable code.&lt;/p&gt;

&lt;p&gt;What do I mean when I say "testable code"? Generally, to me, testable code means that you've designed each class or function to be easily tested in isolation. Often, this means making it slightly more explicit than you might naturally write, writing more, smaller functions and extracting out dependencies (such as database connections) so that you can test each small piece.&lt;/p&gt;

&lt;p&gt;After all, if your function uses a database connection, you aren't probably too concerned with launching an entire database to test that function and testing that the database writes worked &amp;ndash; you are more interested in validating your logic that is wrapped around it. When you call insert_entry, does it convert values correctly, does it call the appropriate methods that would invoke the database, etc.? In general, you can accomplish testing independent of the database by mocking out the database layer when testing out the checkbook logic.&lt;/p&gt;

&lt;p&gt;Going back to our second question, on when do you start testing a given project? I like the philosophy of test-driven development (TDD), where you write the tests before you write the code. This is doubly true if this is code for a client, for your job, or some other code that is meant to be consumed by people other than you, or running any kind logic dealing with other people's data. Furthermore, writing tests first helps you to figure out the architecture of your project a lot better, and to make sure that your architecture is testable from the beginning.&lt;/p&gt;

&lt;p&gt;Writing tests before you write every piece of your software is a good way to do practice defensive coding: ensure that every piece of your programs and libraries are extraordinarily well tested before they're even written. As you write more functionality, keep growing those tests as to ensure that everything cooperates well and that nothing new is going to break the old.&lt;/p&gt;
</content></entry><entry><title>Scala and Clojure</title><link href="2013_01_01_scala_and_clojure" rel="alternate" /><id>2013_01_01_scala_and_clojure</id><published>2013-01-01T21:51:20-00:00</published><updated>2013-01-01T21:51:20-00:00</updated><author><name>Christopher Swenson</name></author><summary type="html">
&lt;p&gt;My primary language for the past few months has been Scala, with some occasionaly bouts of Java.</summary><content type="html">
&lt;p&gt;My primary language for the past few months has been Scala, with some occasionaly bouts of Java.&lt;/p&gt;

&lt;p&gt;I've also started to learn Clojure. The company I am working for is into the JVM stack, and these languages are both based on the JVM.&lt;/p&gt;

&lt;p&gt;As a long-time Java programmer, I appreciate the cleanliness of Scala, and I've grown pretty comfortable with it over the past few months. It's sort of the language that Java really wanted to be when it grew up: all that OO goodness that we love, but without so many mistakes as Java has, and with a helpful smattering of functional programming.&lt;/p&gt;

&lt;p&gt;That said, Scala has some flaws, including some fairly deep ones.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;IDE support is pretty terrible. I tried to use Eclipse and IntelliJ early on, and they were both incredibly broken. I've never gotten them to work well. I just use Sublime Text 2 these days, and I find that Scala is a clean enough language that this isn't too big of a deal.&lt;/li&gt;
&lt;li&gt;Implicits are just a bad idea. The standard library uses them sparingly and fairly well, but this is such a dangerous feature. (For those of you who don't know Scala, implicit functions are used to automatically convert an object of one type to another, under the hood.) It makes sense in a few limited cases, but I groan when I see them now.&lt;/li&gt;
&lt;li&gt;The standard fundamental data types are wasteful and have poor performance. The &lt;code&gt;List&lt;/code&gt; and &lt;code&gt;Map&lt;/code&gt; data types are optimized for adding things to them, but in doing so create lots of extra copies and have very poor access properties. &lt;code&gt;List&lt;/code&gt;, the most fundamental structure, is a damned linked list! This makes me want to cry. &lt;code&gt;OpenHashMap&lt;/code&gt; is better, at least.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;That said, I much prefer Scala to Java at this point.&lt;/p&gt;

&lt;p&gt;Clojure, on the other hands, I am much newer to, and don't have nearly as solid experience with yet, so take my points with a grain of salt.&lt;/p&gt;

&lt;p&gt;Clojure's obsession with immutability is nice from the point-of-view of thread-safety and (theoretical, yet mostly unrealized) concurrency, but at a high cost. Its memory footprint seems to be the worst of the JVM languages, and it defaults to using reflection for most method calls, so it is significantly slower. (Even with proper type annotations, it is slower.)&lt;/p&gt;

&lt;p&gt;Furthermore, I think Clojure is just fundamentally harder to read. I've done my fair share of Lisp programming in the past, and I think that Lisp is just a lot less natural to read, probably because we spend so much time with infix languages.&lt;/p&gt;

&lt;p&gt;Plus, I would posit that Clojure's premise is doomed to failure. A Lisp that doesn't support tail-call optimization and proper recursion seems broken. (And yes, I know about &lt;code&gt;loop&lt;/code&gt;/&lt;code&gt;recur&lt;/code&gt;, but that is essentially a functional for-loop.) Scala does some rudimentary TCO, though it doesn't always tell you the function you wrote can use it.&lt;/p&gt;

&lt;p&gt;The biggest plus for Clojure is that it is JVM (which is also a weakness). It's a plus because it means you can take advangate of the Java ecosystem (logging, libraries, experience, etc.). Which is probably the primary reason we are using it instead of some other functional languages.&lt;/p&gt;

&lt;p&gt;That said, I will be spending quite a bit of time this year learning both in greater detail, so perhaps I will update with further opinions on them.&lt;/p&gt;

&lt;p&gt;(I'm also thinking about getting more into Go this year, and perhaps finally learning Erlang.)&lt;/p&gt;
</content></entry><entry><title>Things I've Learned At Google, Part Two</title><link href="2012_10_10_things_ive_learned_at_google_part_two" rel="alternate" /><id>2012_10_10_things_ive_learned_at_google_part_two</id><published>2012-10-10T13:27:47-00:00</published><updated>2012-10-10T13:27:47-00:00</updated><author><name>Christopher Swenson</name></author><summary type="html">
&lt;p&gt;I've spent the past 19 months working as a software engineer at Google. They have adopted a lot </summary><content type="html">
&lt;p&gt;I've spent the past 19 months working as a software engineer at Google. They have adopted a lot of great practices, some completely their own, and I certainly learned a lot from working them. I thought I would share some of the particular insights I had while working there.&lt;/p&gt;

&lt;p&gt;This first post was about software engineering. This post is more about general workplace practices.&lt;/p&gt;

&lt;h2&gt;If you want to have the best software engineers, then hire smart people and treat them well.&lt;/h2&gt;

&lt;p&gt;I've worked at places in the past where they are good at hiring smart people, but then tend to treat them poorly. Then, they wonder why the leave in droves for companies, like Google, who aren't afraid to buy you a nice chair and keyboard.&lt;/p&gt;

&lt;p&gt;If you want to have great employees, then you have to treat them like it.&lt;/p&gt;

&lt;h2&gt;Open source licensing is important.&lt;/h2&gt;

&lt;p&gt;Open source code is a lot harder than you'd think, and even the most competent software engineers will sometimes try to get away with not following the rules. The license implications in things like the GPL and AGPL are serious business. Before using any code that touches GPL or AGPL (or other similar licenses), educate yourself well on them, or designate someone at your company to be the open source czar to make sure you aren't messing this stuff up. It's not really hard or anything: it's just a little tedious, and incredibly important.&lt;/p&gt;

&lt;h2&gt;Shoes are optional.&lt;/h2&gt;

&lt;p&gt;I worked at mostly "business casual" places prior to Google, but Google goes straight for "casual", bordering on "who cares". And for all that, I never noticed it as a problem. Unless you are violating the health code, do what makes you productive and happy. (For instance, I am more productive when not wearing shoes, but wearing pants (or at least a kilt). YMMV.)&lt;/p&gt;

&lt;h2&gt;Working from home can be fine.&lt;/h2&gt;

&lt;p&gt;Personally, I work better in an office. But, my Google office is about 1 or 1.5 hours away. After a few weeks, I figured out a system where I could be very productive working from home &amp;mdash; certainly efficient enough so that there is a net gain in productivity due to commuting time. So, I spent a lot of time at Google working from home, and did quite well. (Early on, I spent a lot more time in the office, as I was still bright-eyed and bushy-tailed and was still trying to understand all of Google's inner workings, and this required being able to communicate with my coworkers more.)&lt;/p&gt;

&lt;h2&gt;Don't be a gatekeeper unless it is really important.&lt;/h2&gt;

&lt;p&gt;As organizations grow, certain groups start to feel important, entitled, or some other emotion, and begin injecting themselves into every process in the business. Some of these are really important, like privacy and security. For instance, a lot of managers believe that they are not doing anything unless they &lt;em&gt;change&lt;/em&gt; something, and so they sometimes like to start sticking themselves in processes they don't belong in.&lt;/p&gt;

&lt;p&gt;My favorite instance of this at Google is that one of founders has to approve the application package of every single new hire (at least, for software engineers). Even though hiring is important, I am a little doubtful that his review does anything other than make him feel better.&lt;/p&gt;

&lt;p&gt;Becasue of gatekeepers, you can end up with a giant checklist of people who have too much of a say in your project because someone in the past didn't have due diligence.
This can really eat at the velocity of your project, especially small projects (where a just a few people have to deal with all of the gatekeeprs), and definitely at the morale of the team.&lt;/p&gt;

&lt;p&gt;Google is large, and is brimming with gatekeepers. Which I find interesting, because Google has a really neat system for getting rid of gatekeepers: readability.&lt;/p&gt;

&lt;p&gt;Let me explain readability. If you are new to Google or new to a programming language, most of your first code needs to be reviewed by an expert in that field &amp;mdash; a Java expert for example, who can say that your Java code meets all of the standard guidelines to maintainability, readability, and general sanity. After a while, you will become recognized as an expert as well (through a formal process), and you won't need to have this be part of every review anymore.&lt;/p&gt;

&lt;p&gt;Perhaps a solution to gatekeeping would be to have more readability-like things: if you've launched a few projects that tackled certain thorny areas very well, then maybe you now have "readability" in those areas, and we can trust you a little bit more, and remove some bureaucracy from your plate. It's an idea at least. But the moral of the story is: don't insert yourself into the bureaucracy and become part of the problem unless there is no other choice.&lt;/p&gt;

&lt;p&gt;Gatekeepers are a symptom of trust and communication mismanagement. When your product is ready for launch or has made some significant progress, all of a sudden, a bunch of gatekeepers (like your senior managers) take an interest in your project. Some of them will have looked at your project in its early phases to greenlight the concept, but to many of them, they may not have ever heard of you before. And, especially at the very highest levels, they only have 1 bit of communication down to you: launch or cancel.&lt;/p&gt;

&lt;p&gt;This low-bandwidth communication is bad, especially if they see problems with your product or direction, and unfortunately, you may have just wasted a lot of effort (perhaps months or years of engineering) on something that is going in the scrap pile. This is perhaps avoidable by trusting the management below you to make the right decision early on. A senior manager having so much drastic control over a project sends a mixed message about trust.&lt;/p&gt;

&lt;h2&gt;Writing is still incredibly important.&lt;/h2&gt;

&lt;p&gt;Don't get me wrong, I understood this pretty well before. But even at Google, writing is still important. For one thing, any large company probably has a convoluted promotion process, and Google's, while leaner than some, still requires a lot of paperwork. Paperwork means writing, and if you can't communicate effectively about your own accomplishments, then you are just not going to get promoted, at Google or anywhere.&lt;/p&gt;

&lt;p&gt;I've seen people time and time again tell me that "they just aren't good at writing about themselves" &amp;mdash; this has been nonsense every time. They were fine at writing about themselves, they just didn't &lt;em&gt;like&lt;/em&gt; to. In which case, too bad: if you want to get promoted, then just do it.&lt;/p&gt;

&lt;p&gt;If you don't write about it, it didn't happen.&lt;/p&gt;

&lt;h2&gt;Kids aren't nearly as good at computers as I thought they were.&lt;/h2&gt;

&lt;p&gt;While not strictly workplace-related, this is something fun I learned at Google.&lt;/p&gt;

&lt;p&gt;While working from Google, I was often the token Google engineer that was paraded around for local high schoolers that we would do some outreach for. I would answer questions from "how does search work?" to "do they really let you drink at work?". It was rewarding and I really enjoyed talking with them.&lt;/p&gt;

&lt;p&gt;However, they were all just &lt;em&gt;terrible&lt;/em&gt; at technology, despite all that "kids these days" should be masters of all computers, cell phones, and whatnot. They should be tumblring circles around my desktop-loving self when it comes to, well, everything, but I'm pretty sure most of them couldn't program a VCR, or whatever the modern equivalent to that is. (For my younger readers, programming a VCR is perhaps the second most trivial "techie" thing to do in my generation, only slightly above having an alarm clock with the time set correctly (rather than blinking &lt;code&gt;12:00&lt;/code&gt;)).&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;I'm sure I learned more at Google, but those are perhaps some of the important things I felt I learned while working there.&lt;/p&gt;

&lt;p&gt;I can't wait to see what I learn at my next job. :)&lt;/p&gt;
</content></entry><entry><title>Things I've Learned At Google, Part One</title><link href="2012_10_08_things_ive_learned_at_google_part_one" rel="alternate" /><id>2012_10_08_things_ive_learned_at_google_part_one</id><published>2012-10-08T22:15:53-00:00</published><updated>2012-10-08T22:15:53-00:00</updated><author><name>Christopher Swenson</name></author><summary type="html">
&lt;p&gt;I've spent the past 19 months working as a software engineer at Google. They have adopted a lot </summary><content type="html">
&lt;p&gt;I've spent the past 19 months working as a software engineer at Google. They have adopted a lot of great practices, some completely their own, and I certainly learned a lot from working them. I thought I would share some of the particular insights I had while working there.&lt;/p&gt;

&lt;p&gt;This first post will be about software engineering. Shortly, I'll post another about general workplace stuff.&lt;/p&gt;

&lt;p&gt;First, an overall thought: Google was definitely the most professional place I've worked in terms of software engineering. However, just like any software engineering methodologies, their software engineering Kool-Aid is good, but you don't want to drink all of it.&lt;/p&gt;

&lt;h2&gt;Code reviews are a must.&lt;/h2&gt;

&lt;p&gt;Prior to Google, I had done very little formal code review as most projects we were simply "too busy" to "take time out" to do them. They are not even a little bit optional at Google: every change to the codebase must undergo at least one person's review, and possibly many more depending on the exact nature of the change and the person making it. At first, I was very skeptical about this, but I learned that there is so much much value in having this formal process, for a multitude of reasons.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;First, if you have a small team, code reviews are a good way to keep up with what other people on your project are doing, both on a personal level ("Jane is working on feature X"), as well as understanding what the code does. This means that it will be easier for you to make a modification to the codebase, if it is necessary, or even to take ownership of it should something happen (i.e., team member moves on).&lt;/li&gt;
&lt;li&gt;Code reviews don't take as long as you think.&lt;/li&gt;
&lt;li&gt;Code reviews significantly increase the quality of the code produced, both in readability, but in catching bugs and poor design decisions. Perhaps not as much as true pair programming, but with a lot fewer of the disadvantages.&lt;/li&gt;
&lt;li&gt;Unfortunately, code reviews have one downside: it is often tricky to work on two different reviews on the same part of the codebase at the same time. This depends heavily on your version control system &amp;mdash; distributed version control systems, like git, tend to support this pretty well. But even so, there is some cost in terms of "mental swap space", as sometimes it is difficult to focus on an entirely different change until you hear back on your pending change. The best way to avoid this is make sure your team prioritizes reviewing code above pretty much all else, so that your other team members aren't waiting on you. (Code reviews are a bit like a turn-based game, and when it is the other person's turn, it can seem like it takes forever.) I always tried to have a spare project to work on that I could hack on a little while waiting.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2&gt;IDEs are worth it for large projects.&lt;/h2&gt;

&lt;p&gt;Prior to Google, I despised IDEs. I still don't have a lot of love for them, but reusing Google's extensive codebase in my own code finally broke me out of my IDE-less existence: there is simply &lt;em&gt;too much&lt;/em&gt; code to try to wrangle without features like autoimport, name completion, refactoring, etc. I chose Eclipse, because I was doing Java work and Eclipse is well-supported inside Google. As slow as Eclipse is, it saved me a lot of time hunting through docs looking for the right class, with the right class name, the right function name method, etc.: I could just tab-complete my way to freedom a lot of the time.&lt;/p&gt;

&lt;h2&gt;Build systems still suck.&lt;/h2&gt;

&lt;p&gt;Google has their own build system that integrates with, well, everything. But it still sucks. Not as much as autotools, SCons, Makefiles, but it still sucks. Where, oh where, is the build system of my dreams? To be fair, this was probably the best build system I have ever used.&lt;/p&gt;

&lt;h2&gt;Python and other untyped languages make life harder for large projects.&lt;/h2&gt;

&lt;p&gt;For small projects or stuff that I am doing by myself, I love Python. The time it saves me is tremendous. However, nothing is more frustrating than programming with a large, unknown codebase in Python. I would often see code like this, even in a well-manicured codebase:&lt;/p&gt;

&lt;pre&gt;
def ReadFromDatabase(self, query, metadata):
  """Perform the query on the database."""
  ...
&lt;/pre&gt;

&lt;p&gt;So... what is query? A string? What is its format? Could it be a tuple, a list? What is metadata? Essentially, the only answers to these questions were to go digging through documentation, look for other code that calls that function, read through the function itself. And sometimes I just don't have time to go on a coding adventure: I want to call the method and go on with my day. Java, for all of its faults, at least tells you the type information of the parameters, so I have a strong hint for my adventure. This might involve navigating factories, factoryfactories, and all other kinds of abominations, but at least I would have a good start.&lt;/p&gt;

&lt;h2&gt;It should be easy to run your program.&lt;/h2&gt;

&lt;p&gt;Google programmers love command-line flags. They sprinkle them everywhere. The problem is: they often specify the default values elsewhere, perhaps in a script that only runs in production. It can make running a program locally difficult, which in turns makes testing and debugging hard. The moral I learned is that it should be dead simple to build, run, and test your program. Hunting around for documentation on the perfect incantation magic is a real bummer.&lt;/p&gt;

&lt;h2&gt;Test &lt;em&gt;ALL&lt;/em&gt; the things.&lt;/h2&gt;

&lt;p&gt;Before Google, I hadn't really practiced a lot of TDD. Sure, when I had a small piece of code that had very well-defined inputs and outputs, and if I had time, I would create some doctests (in Python) or the equivalent elsewise, but it was never a priority. At Google, good testing is the state religion. If it doesn't have tests, it doesn't exist. No excuses. I don't care how complex the code is: it has to be tested. Writing the tests firsts often helps, but doesn't always make sense.&lt;/p&gt;
</content></entry><entry><title>Blog Redo</title><link href="2012_09_26_blog_redo" rel="alternate" /><id>2012_09_26_blog_redo</id><published>2012-09-27T06:51:02-00:00</published><updated>2012-09-27T06:51:02-00:00</updated><author><name>Christopher Swenson</name></author><summary type="html">
&lt;p&gt;I got tired of the old site having issues, so I rewrote the site using a
custom static site gene</summary><content type="html">
&lt;p&gt;I got tired of the old site having issues, so I rewrote the site using a
custom static site generator.&lt;/p&gt;

&lt;p&gt;Things pretty much work. I am in the process of moving old Disqus comments over
to the new system, and working with a small issue or two there.&lt;/p&gt;

&lt;p&gt;I should have some new material up soon as well!&lt;/p&gt;
</content></entry><entry><title>What Every Programmer Should Know About Memory</title><link href="2012_04_28_what_every_programmer_should_know_about_memory" rel="alternate" /><id>2012_04_28_what_every_programmer_should_know_about_memory</id><published>2012-04-28T22:00:40-00:00</published><updated>2012-04-28T22:00:40-00:00</updated><author><name>Christopher Swenson</name></author><summary type="html">
&lt;p&gt;I was just thinking about this paper today: Ulrich Drepper's "What Every Programmer Should Know </summary><content type="html">
&lt;p&gt;I was just thinking about this paper today: Ulrich Drepper's "What Every Programmer Should Know About Memory".&lt;/p&gt;

&lt;p&gt;&lt;a href="http://www.akkadia.org/drepper/cpumemory.pdf"&gt;http://www.akkadia.org/drepper/cpumemory.pdf&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;If you haven't read it, and you are a programmer, then you really need to read this paper.&lt;/p&gt;
</content></entry><entry><title>Modern Cryptanalysis Errata updated</title><link href="2011_12_30_modern_cryptanalysis_errata_updated" rel="alternate" /><id>2011_12_30_modern_cryptanalysis_errata_updated</id><published>2011-12-30T23:36:33-00:00</published><updated>2011-12-30T23:36:33-00:00</updated><author><name>Christopher Swenson</name></author><summary type="html">
&lt;p&gt;I have updated &lt;a href="http://www.caswenson.com/mcerrata"&gt;the errata&lt;/a&gt; for my book, Modern Cr</summary><content type="html">
&lt;p&gt;I have updated &lt;a href="http://www.caswenson.com/mcerrata"&gt;the errata&lt;/a&gt; for my book, Modern Cryptanalysis.&lt;/p&gt;
</content></entry><entry><title>Changes coming soon</title><link href="2011_12_25_changes_coming_soon" rel="alternate" /><id>2011_12_25_changes_coming_soon</id><published>2011-12-26T04:51:07-00:00</published><updated>2011-12-26T04:51:07-00:00</updated><author><name>Christopher Swenson</name></author><summary type="html">
&lt;p&gt;This is the first post of the year. That's a little sad, but I think I am going to be redoing th</summary><content type="html">
&lt;p&gt;This is the first post of the year. That's a little sad, but I think I am going to be redoing this site a bit in the near future.&lt;/p&gt;

&lt;p&gt;So, some upcoming changes:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Errata for my book -- this link has been on the RHS of my page for quite a while now, and I haven't gotten around to compiling this errata.  I will do so in the next few days.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Notes on upcoming projects. I am currently working on several projects, open source and not, and a few writing projects. Expect more details on these.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;... and more.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</content></entry><entry><title>Monospaced font</title><link href="2010_12_01_monospaced_font" rel="alternate" /><id>2010_12_01_monospaced_font</id><published>2010-12-01T08:40:37-00:00</published><updated>2010-12-01T08:40:37-00:00</updated><author><name>Christopher Swenson</name></author><summary type="html">
&lt;p&gt;I have been searching for years for a decent programming font (that is, monospaced). Over the ye</summary><content type="html">
&lt;p&gt;I have been searching for years for a decent programming font (that is, monospaced). Over the years, I've found various ones that suited me, but recently I found ranks as my favorite: &lt;a href="http://www.cosmix.org/software/"&gt;Droid Sans Mono, Dotted&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src="http://m.caswenson.com/images/droidsansmono.png" width="901" height="649" alt="Droid Sans Mono Dotted picture" /&gt;&lt;/p&gt;

&lt;p&gt;Essentially, cosmix created a dotted and slashed zero variant to Droid Sans Mono, part of the &lt;a href="http://www.droidfonts.com/"&gt;Droid family of fonts&lt;/a&gt; designed for Google's Android operating system.&lt;/p&gt;

&lt;p&gt;They are designed to very legible, and I have found the Sans Mono to be clean and pleasant when in the terminal or in a coding window.  It also has pretty decent Unicode support.&lt;/p&gt;

&lt;p&gt;My previous favorite coding fonts have been: Monaco, DejaVu Sans Mono, Consolas, and Lucida Sans Console.&lt;/p&gt;
</content></entry><entry><title>Sorting out sorting</title><link href="2010_10_30_sorting_out_sorting" rel="alternate" /><id>2010_10_30_sorting_out_sorting</id><published>2010-10-30T10:29:39-00:00</published><updated>2010-10-30T10:29:39-00:00</updated><author><name>Christopher Swenson</name></author><summary type="html">
&lt;p&gt;I &lt;a href="http://github.com/swenson/sort"&gt;recently wrote&lt;/a&gt; a C version of a bunch of comparis</summary><content type="html">
&lt;p&gt;I &lt;a href="http://github.com/swenson/sort"&gt;recently wrote&lt;/a&gt; a C version of a bunch of comparison-based sorting algorithms, notably timsort and quicksort.&lt;/p&gt;

&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Timsort"&gt;Timsort&lt;/a&gt; is a neat, unbalanced mergesort that I've been wanting to try out for the past while, and so I spent the time to write a fast C implementation of the algorithm.  My experiments on random data show about a 5-10% improvement over quicksort, which is pretty amazing.  If the data has any structure, which is extremely common, it has "superhuman" performance, as it can merge natural runs in the data in an efficient manner.&lt;/p&gt;

&lt;p&gt;Another annoying thing I've noticed is that I've written the same sorting algorithms a ton of times, often just changing the type.  Sometimes I've used the standard C &lt;a href="http://fxr.watson.org/fxr/source/stdlib/qsort.c?v=GLIBC27"&gt;qsort&lt;/a&gt;, but the function-pointer comparison function causes awful performance (the version I wrote isn't even as optimized, and is still often twice as fast).  Why can't I just write a good, fast sorting algorithm?&lt;/p&gt;

&lt;p&gt;A solution comes from a neat trick in C: &lt;a href="http://en.wikipedia.org/wiki/C_preprocessor#Token_concatenation"&gt;token pasting&lt;/a&gt;.  Using this, it's possible to write the function once, and just swap out the types as needed.&lt;/p&gt;

&lt;p&gt;Using token pasting, it is also possible to implement the entire library as a single header file: no library to compile!&lt;/p&gt;

&lt;p&gt;Sadly, sorting doesn't usually have &lt;a href="http://www.youtube.com/watch?v=YvTW7341kpA"&gt;sound effects&lt;/a&gt;.&lt;/p&gt;
</content></entry>
</feed>
